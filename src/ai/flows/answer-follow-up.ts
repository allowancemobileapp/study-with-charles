
'use server';
/**
 * @fileOverview Handles follow-up questions based on previous AI-generated context and optional new file.
 *
 * - answerFollowUp - A function that takes previous context, a new query, and an optional file.
 * - AnswerFollowUpInput - The input type for the answerFollowUp function.
 * - AnswerFollowUpOutput - The return type for the answerFollowUp function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AnswerFollowUpInputSchema = z.object({
  previousResultText: z
    .string()
    .min(1)
    .describe('The text of the previous AI response that provides context.'),
  followUpQuery: z
    .string()
    .min(1)
    .optional()
    .describe('The user\'s follow-up question related to the previous context.'),
  subjectTitle: z.string().min(1).describe('The original subject or course title for context.'),
  desiredFormat: z
    .enum(['Text', 'Summary', 'Question Answering', 'Explain'])
    .describe('The original desired format, to guide the style of the follow-up answer.'),
  fileDataUri: z
    .string()
    .describe(
      "An optional file's content for the follow-up, as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ).optional(),
});
export type AnswerFollowUpInput = z.infer<typeof AnswerFollowUpInputSchema>;

const AnswerFollowUpOutputSchema = z.object({
  followUpAnswer: z.string().describe('The AI\'s answer to the follow-up question.'),
  followUpImageUrl: z.string().optional().describe("An optional URL to an image generated by the AI for the follow-up, if relevant.")
});
export type AnswerFollowUpOutput = z.infer<typeof AnswerFollowUpOutputSchema>;

export async function answerFollowUp(input: AnswerFollowUpInput): Promise<AnswerFollowUpOutput> {
  return answerFollowUpFlow(input);
}

const answerFollowUpFlow = ai.defineFlow(
  {
    name: 'answerFollowUpFlow',
    inputSchema: AnswerFollowUpInputSchema,
    outputSchema: AnswerFollowUpOutputSchema,
  },
  async (input) => {
    console.log("AI Flow: answerFollowUpFlow - Initiated with input:", {
        subjectTitle: input.subjectTitle,
        desiredFormat: input.desiredFormat,
        followUpQueryLength: input.followUpQuery?.length || 0,
        previousResultTextLength: input.previousResultText.length,
        fileDataUriPresent: !!input.fileDataUri,
    });

    const promptMessages: ({text: string} | {media: {url: string}})[] = [];

    promptMessages.push({ text: `You are an AI assistant helping a student with the subject: "${input.subjectTitle}". The student is asking a follow-up.` });
    promptMessages.push({ text: `PREVIOUS CONTEXT (from prior AI interaction):\n${input.previousResultText}\n\nEND OF PREVIOUS CONTEXT.` });

    if (input.followUpQuery && input.fileDataUri) {
        promptMessages.push({ text: `The student's FOLLOW-UP QUESTION is: "${input.followUpQuery}".` });
        promptMessages.push({ text: `The student has also provided a NEW FILE for this follow-up. Use this new file as primary context if it's relevant to the follow-up question, otherwise rely on the PREVIOUS CONTEXT and the follow-up question.\nNEW FILE CONTENT:`});
        promptMessages.push({ media: { url: input.fileDataUri } });
    } else if (input.followUpQuery) {
        promptMessages.push({ text: `The student's FOLLOW-UP QUESTION is: "${input.followUpQuery}". Answer this based on the PREVIOUS CONTEXT.` });
    } else if (input.fileDataUri) {
        promptMessages.push({ text: `The student has provided a NEW FILE for this follow-up. Analyze this new file in the context of the PREVIOUS CONTEXT and provide relevant information, explanation, or answer implied questions from the new file.\nNEW FILE CONTENT:`});
        promptMessages.push({ media: { url: input.fileDataUri } });
    } else {
        promptMessages.push({ text: `The student has not provided a specific follow-up question or a new file. Please offer a brief, general continuation or clarification based on the PREVIOUS CONTEXT and the original desired format of "${input.desiredFormat}".` });
    }
    
    let mainInstruction = "";
    if (input.desiredFormat === 'Question Answering' && (input.followUpQuery || input.fileDataUri)) {
        mainInstruction = `Based on the PREVIOUS CONTEXT, the student's FOLLOW-UP (question and/or new file), provide a concise and direct answer or analysis. If the follow-up implies generating new Q&A from the new file, generate 1-2 new, distinct questions and their answers related to the new file and in line with the follow-up. The entire output for this task, if generating new Q&A, MUST be a single, valid JSON string representing an array of objects, each with "Question" and "Answer" string properties. Example: [{"Question": "Q1?", "Answer": "A1."}]. If simply answering or analyzing, provide a direct textual answer.`;
    } else { 
        mainInstruction = `Based on the PREVIOUS CONTEXT and the student's FOLLOW-UP (question and/or new file), provide a comprehensive textual response. Maintain a style consistent with "${input.desiredFormat}". Answer any explicit questions, or analyze/explain content from any new file provided.`;
    }
    promptMessages.push({ text: `\nTask Instructions for Follow-up:\n${mainInstruction}\nYour entire response will be the value for the 'followUpAnswer' field in a JSON object.` });

    console.log("AI Flow: answerFollowUpFlow - Final prompt messages preview (text parts):", JSON.stringify(promptMessages.filter(m => 'text' in m).map(m => (m as {text:string}).text.substring(0,200) + "..."), null, 2));
    
    try {
      console.log("AI Flow: answerFollowUpFlow - Calling ai.generate with model 'googleai/gemini-1.5-flash-latest'.");
      
      const response = await ai.generate({
        prompt: promptMessages, 
        model: 'googleai/gemini-1.5-flash-latest',
        output: { schema: AnswerFollowUpOutputSchema }, 
        config: {
          safetySettings: [
            { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
          ],
        },
      });
      
      console.log("AI Flow: answerFollowUpFlow - Raw response object from ai.generate():", JSON.stringify(response, null, 2).substring(0, 1000) + (JSON.stringify(response).length > 1000 ? "..." : ""));

      const output = response.output; 
      console.log("AI Flow: answerFollowUpFlow - Extracted output field from response:", JSON.stringify(output, null, 2).substring(0,1000));


      if (!output || typeof output.followUpAnswer !== 'string') {
        const receivedOutputDetails = output ? JSON.stringify(output, null, 2) : 'null or undefined output field';
        console.error('AI Flow: answerFollowUpFlow - AI model returned invalid or missing output structure. Output.followUpAnswer was not a string. Output received:', receivedOutputDetails);
        console.error('AI Flow: answerFollowUpFlow - Full response object for context:', JSON.stringify(response, null, 2));
        throw new Error('AI model did not return a valid follow-up answer. Expected a JSON object with a "followUpAnswer" string field.');
      }
      console.log("AI Flow: answerFollowUpFlow - Successfully received and parsed output. Answer length:", output.followUpAnswer.length, "ImageUrl present:", !!output.followUpImageUrl);
      return output;

    } catch (e: unknown) {
      console.error('CRITICAL ERROR in AI Flow (answerFollowUpFlow): Details below.');
      let errorMessage = 'AI follow-up flow failed during processing.';
      if (e instanceof Error) {
        console.error('Error Name:', e.name);
        console.error('Error Message:', e.message);
        if (e.stack) console.error('Error Stack:', e.stack);
        errorMessage = `AI follow-up flow failed: ${e.message}`;
        const anyError = e as any;
        if (anyError.details) console.error('Error Details:', anyError.details);
        if (anyError.status) console.error('Error Status:', anyError.status);
        if (anyError.cause) console.error('Error Cause:', anyError.cause);
      } else {
        console.error('Unknown error type caught in AI Flow (answerFollowUpFlow):', e);
        errorMessage = 'An unknown error occurred in the AI follow-up flow processing.';
      }
      throw new Error(errorMessage);
    }
  }
);

    